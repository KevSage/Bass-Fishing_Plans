# app/services/rate_limits.py
from __future__ import annotations

import os
import sqlite3
import time
from datetime import datetime
from typing import Optional

# Postgres support
try:
    import psycopg
    from psycopg.rows import dict_row
except ImportError:
    psycopg = None

class RateLimitStore:
    """
    Manages a simple 10-plan-per-day limit for members.
    Supports both SQLite (local) and Postgres (Vercel).
    """
    def __init__(self, path: str = "data/rate_limits.sqlite3"):
        self._pg_url = os.getenv("DATABASE_URL")
        self._use_pg = bool(self._pg_url and self._pg_url.startswith("postgres"))
        
        if self._use_pg:
            self._init_pg()
        else:
            os.makedirs(os.path.dirname(path), exist_ok=True)
            self.path = path
            self._init_db()
    
    def _conn(self):
        if self._use_pg:
            return psycopg.connect(self._pg_url, row_factory=dict_row)
        conn = sqlite3.connect(self.path)
        conn.row_factory = sqlite3.Row
        return conn

    def _get_p(self) -> str:
        return "%s" if self._use_pg else "?"
    
    def _init_pg(self) -> None:
        with self._conn() as conn:
            # We only need one table now for daily member usage
            conn.execute("""
                CREATE TABLE IF NOT EXISTS daily_usage (
                    email TEXT, 
                    day TEXT, 
                    count INTEGER, 
                    PRIMARY KEY(email, day)
                );
            """)
            conn.commit()
    
    def _init_db(self) -> None:
        with self._conn() as conn:
            conn.execute("""
                CREATE TABLE IF NOT EXISTS daily_usage (
                    email TEXT, 
                    day TEXT, 
                    count INTEGER, 
                    PRIMARY KEY(email, day)
                );
            """)
            conn.commit()

    def get_daily_count(self, email: str) -> int:
        """Returns the number of plans generated by this email today."""
        today = datetime.now().strftime("%Y-%m-%d")
        p = self._get_p()
        with self._conn() as conn:
            row = conn.execute(
                f"SELECT count FROM daily_usage WHERE email={p} AND day={p}",
                (email.lower().strip(), today)
            ).fetchone()
            return row["count"] if row else 0

    def increment_daily_count(self, email: str) -> None:
        """Increments the daily plan tally for a member."""
        today = datetime.now().strftime("%Y-%m-%d")
        email_clean = email.lower().strip()
        p = self._get_p()
        # Handle syntax differences for UPSERT
        ex = "EXCLUDED" if self._use_pg else "excluded"
        
        with self._conn() as conn:
            conn.execute(
                f"""INSERT INTO daily_usage (email, day, count) VALUES ({p}, {p}, 1)
                   ON CONFLICT(email, day) DO UPDATE SET count = daily_usage.count + 1""",
                (email_clean, today)
            )
            conn.commit()

    def is_within_daily_limit(self, email: str, limit: int = 10) -> bool:
        """Check if the user is under the daily cap."""
        # Bypass for admin/test accounts
        bypass = os.getenv("RATE_LIMIT_BYPASS_EMAILS", "").lower().split(",")
        if email.lower().strip() in bypass:
            return True
            
        return self.get_daily_count(email) < limit